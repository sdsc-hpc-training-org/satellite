#!/usr/bin/perl
# cron
# run this via cron from an account that can write the httpd config stub

use strict;
use Cwd;
use File::Basename qw(dirname); 
use lib(dirname(Cwd::abs_path($0)) . '/../etc');
use satconfig;
use DBI;
use Digest::SHA qw(sha256_hex);
use Data::Dumper;

my $basename = dirname(Cwd::abs_path($0));
chdir $basename;

# this will turn into a series of vhost entries
my $template = <<_VHOST_BODY_;
<VirtualHost *:_LISTENPORT_>
    SSLEngine on

    ServerName _ALIAS_._EXTBASENAME_
    RewriteEngine on
    RewriteCond %{HTTP:Upgrade} websocket [NC]
    RewriteCond %{HTTP:Connection} upgrade [NC]
    RewriteRule .* "_WS_TARGET_%{REQUEST_URI}" [P]

    ProxyPass "/" "_PROXY_TARGET_"
    ProxyPassReverse "/" "_PROXY_TARGET_"
</Virtualhost>
_VHOST_BODY_

my $dbfile = $satconfig::dbfile;
my $listenport = $satconfig::listenport;
my $extport = $satconfig::extport;
my $extbasename = $satconfig::extbasename;
my $httpdstubfile = $satconfig::httpdstubfile;
my $poolgroup = $satconfig::revssh_group;

# key = account name, val = 0 if not in use, 1 if in use
# processes owned by a not-in-use account get killed.
my %poolinuse;

# populate the revssh account pool, all accounts are initially
# not used.
my @grent = getgrnam($poolgroup);
if ( @grent )
{
    my @tpool = split('\s+', $grent[3]);
    while ( my $acct = shift(@tpool) )
    {
        $poolinuse{$acct} = 0;
    }
}

# connect to the db since that's the remainder of what we do.
our $dbh = DBI->connect("dbi:SQLite:dbname=$dbfile", "", "", {
  AutoCommit => 0,
  RaiseError => 1,
});

# output is an array to be joined later.
my @output;

# newly mapped hosts should have state flipped to proxied
# so client js knows to trigger refresh.
my @map2proxy;

# clear out old junk
my $mincreate = time() - $satconfig::ttl_secs;
my $sth = $dbh->prepare("delete from proxy where modified < datetime(?,'unixepoch')");
$sth->execute($mincreate);
$sth = $dbh->prepare("select alias, dsthost, dstport, state, revssh_user from proxy where (state = 'mapped' or state = 'proxied') order by alias asc");
$sth->execute();
$dbh->commit;
while (my @row = $sth->fetchrow)
{
    #print Dumper(@row);
    my $alias = $row[0];
    my $dsthost = $row[1];
    my $dstport = $row[2];
    my $state = $row[3];
    my $revssh_user = $row[4];

    # quietly skip entries with crap
    next unless ( $alias =~ /^[-a-zA-Z0-9]+$/ );
    next unless ( $dsthost =~ /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/ );
    next unless ( !defined $dstport || $dstport =~ /^[0-9]{4,5}$/ );
    next unless ( !defined $dstport || $dstport > 1023 && $dstport < 65536 );
    next unless ( !$revssh_user || $revssh_user =~ /^[-a-zA-Z0-9_.]+$/ );
    next unless ( defined $dstport || defined $revssh_user );
    next if ( defined $dstport && defined $revssh_user );

    my $proxytarget = '';   
    my $wstarget = '';
    if ( $revssh_user )
    {
        $proxytarget = sprintf("unix://%s/%s/socket/tunnel|http://localhost/",
          $satconfig::revssh_chroot_dir, $revssh_user);
        $wstarget = sprintf("unix://%s/%s/socket/tunnel|ws://localhost/",
          $satconfig::revssh_chroot_dir, $revssh_user);
        # mark the account as in-use so we don't clean its processes
        # check for existence first, because there might be junk in the db
        # ... this gets passed to pkill
        $poolinuse{$revssh_user} = 1 if ( defined $poolinuse{$revssh_user} );

    } else
    {
        $proxytarget = sprintf("http://%s:%d/", $dsthost, $dstport);
        $wstarget = sprintf("ws://%s:%d/", $dsthost, $dstport);
    }
    
    my $tmpblock = $template;
    $tmpblock =~ s/_LISTENPORT_/$listenport/g;
    $tmpblock =~ s/_EXTPORT_/$extport/g;
    $tmpblock =~ s/_EXTBASENAME_/$extbasename/g;
    $tmpblock =~ s/_ALIAS_/$alias/g;
    $tmpblock =~ s/_DSTHOST_/$dsthost/g;
    $tmpblock =~ s/_DSTPORT_/$dstport/g;
    $tmpblock =~ s/_PROXY_TARGET_/$proxytarget/g;
    $tmpblock =~ s/_WS_TARGET_/$wstarget/g;

    unshift(@output, $tmpblock);

    unshift(@map2proxy, $alias) if ( $state eq 'mapped' );
}

my $newbody = join("\n", @output);
my $newbodyhash = sha256_hex($newbody);

# mark mapped entries as proxied
$sth = $dbh->prepare("update proxy set state = 'proxied' where alias = ?");
foreach my $a (@map2proxy)
{
    $sth->execute($a);
}
$dbh->commit;

# get the current body hash to see if any changes need to be made.
my $sha = Digest::SHA->new(256);
$sha->addfile($httpdstubfile);
my $currentbodyhash = $sha->hexdigest;

# update if different.
if ( lc($newbodyhash) ne lc($currentbodyhash) )
{
    open(my $ofh, ">", $httpdstubfile) or die("Can't write to $httpdstubfile: $!");
    print $ofh ($newbody);
    close($ofh);
    
    # trigger a graceful reload of httpd. 
    # the pid file might contain junk, especially if we're in a container.
    # use kill instead.
    if ( $> != 0 )
    {
        system("sudo killall -USR1 httpd apache2 2>/dev/null");
    }
    else
    {
        system("killall -USR1 httpd apache2 2>/dev/null");
    }
}

# if revssh_group isn't being used, there's nothing further to
# do here.
exit if ( scalar keys %poolinuse == 0 );

# clean up processes owned by a not-used revssh account.
# the naive approach of pkilling each not-used account is
# horribly noisy, especially when sudo is involved.
#
# further, the size of poolinuse could be very large, so we can't
# stick every account on a command line.
#
# this requires some more thought.

# lets see which accounts are actually running something
my @acctsrunning = split(/\n+/, `ps -g $poolgroup -o euser --no-headers | sort | uniq`);

# build a list of accounts to pkill
my @acctstokill = grep($poolinuse{$_}  == 0 , @acctsrunning);
if ( scalar @acctstokill > 0 )
{
    my $acctstokillarg = join( ',', @acctstokill);
    if ( $> != 0 )
    {
        system("sudo pkill -9 -u $acctstokillarg");
    } else
    {
        system("pkill -9 -u $acctstokillarg");
    }
}
